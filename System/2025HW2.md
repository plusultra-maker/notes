# HW2  进程线程模型与调度
> 2000011483 喻勃洋
## 调度算法特点及优劣
- FIFO 
  - 简而言之就是谁先到谁先服务。
  - 优点是实现起来简单，几乎不用考虑太多问题，而且每个进程很公平
  - 缺点是没有智能性：前面有个很慢的进程，后面的进程就只能等，平均等待时间就会偏长，对短作业特别不友好。

- SJF 
  - 其意思是总先做时间短的任务
  - 相比于FIFO，这样理论上能让所有任务的平均等待时间最短
  - 缺点是要求提前知道每个任务需要多少时间，而且如果总是优先做短作业，长作业就有可能一直得不到机会，造成饥饿现象。而且因为它是不抢占式的，所以一旦开始，响应时间就不太灵活。

- STCF 或 SRTN 就是 SJF 的抢占版。
  - 当新任务来了，如果它比当前任务还要短，就会抢过来先执行。这样做的话响应时间更好，但同样需要知道任务执行时间
  - 而且频繁的抢占会带来不少上下文切换的额外开销，长作业也可能会一直被抢。

- Round Robi
  - 给每个进程分个固定的时间片，就像轮流发言一样。这样公平性不错，响应时间也可以预测，适合需要频繁交互的系统
  - 但平均周转时间可能会比较长。如果时间片太长，就有点像FIFO；如果太短，上下文切换的开销又会太大。



## xv6-riscv 进程模型与调度
### shell、fork()、exec()和wait()之间的关联
他们的各自的作用：
- shell作为用户交互界面，负责接收用户命令并创建相应进程来执行这些命令
- fork()创建一个当前进程的副本（子进程），具有相同的内存内容但有独立的地址空间
- exec()在当前进程中加载并执行新程序，替换原有的程序内容
- wait()使父进程阻塞等待子进程终止，并回收子进程资源
这种设计的好处在于：
- shell提供了灵活的进程创建和管理机制，便于比如在init时控制指挥进程的发生和执行
- 通过fork()和exec()的组合，允许父进程创建子进程并执行不同的程序
- 子进程可以在执行新程序前进行一些准备工作（如设置文件描述符）
- 父子进程隔离，子进程崩溃不会影响父进程，而且可以通过wait()回收资源，避免僵尸进程的产生

### xv6的调度算法分析
- xv6 的调度是基于进程的，不是基于线程的（因为 xv6 并没有真正实现用户级线程，所有的调度单位其实就是进程）。它用的是上面回答 __Round Robin__ 策略。
- 调度器会不停地扫描整个进程表，找那些状态是 _RUNNABLE_ 的进程。找到后，就把其中一个分配给 CPU 去运行。它是RR不考虑进程优先级，也就是说所有进程被一视同仁，谁准备好了就谁先上。进程运行过程中，要么自己让出 CPU（比如执行 sleep 或等待 I/O），要么就是被时钟中断打断，这时候调度器会介入，切换到下一个可运行的进程。
- 关于多核系统上，xv6 每个核都会跑一个独立的调度器，各自挑选可运行的进程，但不会做太多协调，所以有可能出现一个核很忙，另一个核却闲着的情况。
- 可能的改进：
  - 优先级：可以考虑允许进程设置优先级，优先级高的进程可以更快地获得 CPU 时间，从而用户感觉到更流畅。
  - 负载均衡：可以考虑在多核系统上实现更好的负载均衡，比如强制把 CPU 时间片分配给不同的核，避免某个核过载。
  - 支持 CPU 亲和性：让进程尽量跑在之前用过的核上，可以减少缓存失效，提高效率