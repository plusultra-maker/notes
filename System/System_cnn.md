# 操作系统（based on PKU course）
## 本质
- 管理其他软件的软件，把计算机的硬件资源分配给各个应用程序，提供基本的api

## 视角
- 资源管理
- 进程管理
  - 内核来管进程的创建和销毁
- 虚拟机
  - 操作系统是一个虚拟机，提供了一个抽象的计算机模型

## 特征
- concurrency 并发
  - 多个进程同时运行
  - 在同一个cpu上交替运行（并发），而不是同时运行（并行）
  - 
- 共享
  - 内存上同时存在多个进程
  - 其他资源，如文件、io设备等，可能同时或者交替使用
- 虚拟化
  - 物理资源被抽象成逻辑资源
  - 逻辑资源可以被多个进程共享

## 发展历史
总的来说就像
- 开始是独占
- 终端会控制

## 分类
- 批处理系统
  - 早期的操作系统，用户提交作业，操作系统批量（顺序）处理
  - 没有交互，效率低
  -  批处理操作系统的区别#
单道批处理：一次只能执行一个作业，作业按顺序依次执行，前一个作业完成后才能执行下一个
多道批处理：内存中同时存放多个作业，CPU在这些作业之间切换执行，提高了CPU利用率和系统吞吐量
- 分时操作系统、
  - 多用户系统，多个用户同时使用计算机(cpu间隔的时间片分配给不同的用户)
  - 交互式操作系统，用户可以和计算机交互，有终端
- 实时操作系统

### 重点：
重点小结#
6.1 典型的国产操作系统#
麒麟、鸿蒙、Openeuler、统信等

6.2 核心概念#
操作系统的概念
理解操作系统的不同角度
操作系统的主要特征
典型的、历史上/当前有重要意义的操作系统
重要的操作系统技术及相关技术
多道程序设计
中断
通道
SPOOLing技术
操作系统的分类
6.3 重要历史操作系统#
OS/360
MULTICS
6.4 操作系统特征#
并发
共享
虚拟
随机性

# 中断异常机制
## 中断异常机制
- 显然这个名字并不好理解
  - 这里要讨论的是操作系统是运行的，如何与应用程序交互的
- “操作系统是由中断/异常/事件驱动的“
  - 操作系统被外部的软硬件产生的中断/异常/事件call到，然后响应
- 不同
  - 中断通常由外部设备（如键盘、鼠标、网络接口等）产生
  - 异常通常由CPU在执行指令时检测到的错误（如除零错误、非法指令等）产生
  - 中断处理程序通常较为简单，主要负责响应外部设备的请求，而异常处理程序则需要更复杂的错误处理机制。
- 异常
  - 异常分为四类：陷入（Trap）、故障（Fault）、终止（Abort）和中断（Interrupt）
  - 陷入：陷入是由用户程序主动触发的同步事件，本质上是系统调用的一种方式
  - 故障
    - 故障是一种由程序错误引起的异常情况，通常可以被操作系统“修复”后，程序可以继续运行。
    - 访问的虚拟内存页尚未加载到物理内存。
  - 终止
    - 终止是一种由程序错误引起的异常情况，通常无法被操作系统“修复”，程序必须终止。
    - 例如，除零错误、非法指令等。
  - 中断
    - 中断是一种由外部事件引起的异常情况，通常是由硬件设备（如键盘、鼠标、网络接口等）产生的。
- 怎么处理
  - 硬件负责检测中断/异常、保存当前的处理器状态、查找中断向量表并跳转到相应的中断/异常处理程序。
  - 软件负责具体的中断/异常处理逻辑，包括错误处理、资源管理和恢复系统状态等。
  - 处理完成后恢复处理器状态，返回到中断前的执行点继续执行。
- 操作系统初始化
  - 始化时会设置中断向量表、初始化中断控制器、注册中断/异常处理程序
- X86有哪些控制和状态寄存器？所起的作用是什么？
  - X86处理器有多个控制和状态寄存器，包括CR0-CR4（控制寄存器）、EFLAGS（状态寄存器）、GDTR/IDTR（全局/中断描述符表寄存器）等。控制寄存器用于控制处理器的操作模式，状态寄存器保存处理器的状态标志，描述符表寄存器用于存储全局和中断描述符表的地址。
- 其他的等下再说
- ECF 异常控制流
  - ECF描述了应用程序在运行过程中如何通过系统调用、异常和中断等机制与操作系统进行交互。它包括了应用程序的控制流、数据流和异常处理等方面的内容。
  - 通过理解中断和异常的处理流程，可以更好地设计和实现多线程、多进程的并发程序

## CPU调度
- 寄存器
  - 用户可见寄存器
    - 通用寄存器：用于存储数据和地址
  - 控制寄存器
    - 程序计数器（PC）：存储下一条要执行的指令的地址
    - 指令寄存器（IR）：存储当前正在执行的指令
    - 状态寄存器（SR）：存储处理器的状态信息，如中断使能位、条件码等

## 保护与状态
- 操作系统依赖于硬件机制来隔离操作系统和用户程序
- 处理器的不同运行模式
  - 过特权级别，处理器可以区分内核态和用户态，从而控制哪些指令可以在特定模式下执行
- 例如X86架构中的EFLAGS寄存器，RISC-V的三种特权模式：
  - 机器模式(M模式)
  - 用户模式(U模式)
  - 监管模式(S模式)
- 特权指令和非特权指令#
操作系统需要两种CPU状态：
- 特权指令：只能由操作系统使用、用户程序不能使用的指令 
- 非特权指令：用户程序可以使用的指令
- X86支持4个处理器特权级别(特权环 Ring)：R0、R1、R2和R3
  - R0相当于内核态，特权能力最高
  - R3相当于用户态，特权能力最低
- 状态切换
  - 用户态 → 内核态：唯一途径是通过中断/异常/陷入机制（Trap）
  - 内核态 → 用户态：通过设置程序状态字PSW，恢复用户态的寄存器状态

## 中断机制
- CPU对系统发生的某个事件作出的一种反应：

  CPU暂停正在执行的程序
  保留现场后自动转去执行相应事件的处理程序
  处理完成后返回断点，继续执行被打断的程序
  特点：

  是随机发生的
  是自动处理的
  是可恢复的
- 中断的引入
  - 为了支持CPU和设备之间的并行操作
  - cpu计算完了给外部设备去处理，然后算别的，外部设备处理完了给cpu发中断，cpu再去处理外部设备的新结果
- 异常的引入
  - 异常是由CPU在执行指令时检测到的错误（如除零错误、非法指令等）产生的或者由用户程序主动触发的同步事件（如系统调用）产生的。
  - 异常处理程序通常较为复杂，主要负责响应外部设备的请求，而异常处理程序则需要更复杂的错误处理机制。
- 事件
  - 前面的中断和异常都是事件的一种，事件是指在计算机系统中发生的任何事情，包括硬件事件（如中断）、软件事件（如异常）和用户事件（如输入）。
"""
类别	原因	异步/同步	返回行为
中断(Interrupt)	来自I/O设备、其他硬件部件	异步	总是返回到下一条指令
陷入(Trap)	有意识安排的	同步	返回到下一条指令
故障(Fault)	可恢复的错误	同步	返回到当前指令
终止(Abort)	不可恢复的错误	同步	不会返回
"""
- 工作原理
  - 硬件——中断响应过程示意
  - 中断响应过程
    - 1. CPU执行完当前指令后，扫描中断寄存器，检查是否有中断请求
    - 2. 如果有中断请求，保存当前程序的状态（PC、PSW等）
    - 3. 禁止中断，防止嵌套中断
    - 4. 硬件根据中断向量表找到对应的中断处理程序地址
    - 5. 跳转到中断处理程序执行相应的操作
    - 6. 恢复程序状态，允许中断，返回到被打断的程序继续执行
  - 中断向量表
    - 一个内存单元，存放中断处理程序入口地址和程序运行所需的处理机状态字
    - 硬件执行流程按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序
- 上半部和下半部
  - 上半部：中断处理程序的前半部分，主要负责保存现场、处理中断请求、调用下半部等操作。
    - 减少时间，回复接受中断的能力
    - 上半部运行在中断上下文中，通常会暂时关闭中断，不能被阻塞，也不能进行复杂的操作。
    - 典型的上半部操作包括：读取硬件寄存器、清除中断源、调度下半部等。
  - 下半部：中断处理程序的后半部分，主要负责具体的中断处理逻辑，包括错误处理、资源管理和恢复系统状态等。
    - 下半部运行在进程上下文中，可以被阻塞，也可以进行复杂的操作。
    - 典型的下半部操作包括：数据处理、更新数据结构、唤醒等待的进程等。
> 例如，当网卡收到网络包后，通过 DMA 将数据写入内存，并通过硬件中断通知内核有新数据到达。内核调用中断处理程序，分为上半部和下半部。上半部会先禁止网卡中断，避免频繁硬中断降低内核效率，然后触发软中断，将耗时且复杂的任务交给软中断处理程序（下半部）处理，如解析网络数据并将其传递给应用程序。
  - 好处  
    - 提高响应速度
    - 分离紧急与否
    - 而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程
- IA32 体系结构对中断的支持
  - 再说
## 系统调用(System call)
系统调用是用户在编程时可以调用的操作系统功能：
- 系统调用是操作系统提供给编程人员的唯一接口
- 会使得CPU从用户态切换到内核态

- 静态：系统调用机制的设计
后面的没看

# 进程线程模型
## 进程线程模型
- 概念
  - 顺序程序与顺序环境
    - 按顺序执行的程序，顺序环境是指 没有其他程序在运行的环境
  - 并发环境与并发程序
    - 单处理器上有两个或以上程序同时处于开始运行但尚未结束的状态
- 进程
  - 每个进程通常拥有独立的地址空间
  - 系统把cpu时间分配给进程，或者控制cpu
  - 状态
    - 运行态
    - 就绪态
    - 阻塞态/等待态
    - 其他的
- 进程控制块
  - 数据结构，用于存储进程的状态信息
  - 包括
    - 描述
      - PID
      - 进程名
      - UIC
      - 组关系
    - 控制
      - 状态
      - 优先级
      - CPU context--寄存器等，即进程的上下文
      - 调度信息
    - 资源分配
      - 虚拟地址空间描述 (指向页表/段表的指针)。
      - 打开文件描述符表
      - I/O设备信息 
- 进程的地址空间--虚拟内存
  - 布局
    - 代码段
    - 数据段
    - 堆
    - 动态链接库
    - 栈
    - 内核占用的空间
  - 写时复制 (Copy-on-Write, COW): 
    - fork() 创建子进程时，并不立即复制整个地址空间，而是让父子进程共享物理页面，并将页面标记为只读。当任何一方尝试写入时，触发异常，内核才真正复制该页面，使其私有化。这极大地优化了 fork() 的效率，特别是 fork() 后立即 exec() 的情况，因为exec()会替换整个地址空间，使得大部分共享页面在被写入前就已被丢弃，从而避免了不必要的复制开销。
    - 上面的异常处理流程
      - 1. fork() 创建子进程时，父子进程共享物理页面，并将页面标记为只读。
      - 2. 当父或子进程尝试写入共享页面时，触发异常。
      - 3. 内核捕获异常，复制该页面（到新的物理页），并将其标记为可读写。
      - 4. 更新页表，将新页面的地址映射到当前进程的虚拟地址空间。
      - 5. 恢复执行，允许当前进程继续写入新复制的页面。
  - 进程队列-PCB的队列
    - 就绪队列 
      - 回忆就绪对应着ready，但没有cpu
    - 等待队列
      - 等地是等待外部的某个事件来call，比如io设备的输入输出完成，再把PCB放回就绪队列
- 进程控制
  - Primitive 原语
    - 完成某种特定功能的一段程序，不能断的原子操作
  - 进程的生命周期
    - 创建
      - 给新进程分配一个唯一标识(pid)以及进程控制块(PCB)
      - 分配资源--内存、文件描述符等
      - 初始化进程控制块
    - 终止
      - 结束子进程或线程
      - 收回所以的资源
      - 释放PCB
    - 进程阻塞和进程唤醒
      - 处于运行状态的进程，在其运行过程中期待某一事件发生（如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息），当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。
  - Unix的进程控制原语
    - fork()：创建一个新进程，返回值为子进程的PID
    - exec()：用新的程序替换当前进程的映像，返回值为0
    - wait()：等待子进程结束，返回值为子进程的PID
    - exit()：终止当前进程，返回值为退出状态码
  - fork()的实现
    - 为子进程分配一个空闲的进程描述符（proc结构）
    - 分配给子进程唯一标识pid
    - 一次一页的复制父进程的地址空间
    - 继承共享的文件描述符
    - 设置子进程的状态为就绪态
    - 将子进程加入就绪队列
    - 返回子进程的pid给父进程
- 线程
  - 意义
    - 应用程序内部往往有多个并发执行流的需求
    - 进程创建、销毁、切换的开销（时间、空间）较大
    - 线程是轻量级的
      - 同时可以共享进程的地址空间和资源，不需要内核接入
      - 真正的并行
  - Thread
    - 进程内的一个 执行实体
    - 拥有独立的状态
    - 拥有独立的执行上下文: 程序计数器 (PC), 寄存器集合, 栈 (Stack) 和栈指针 (SP)。线程切换时保存/恢复的是这部分私有上下文。
      - 但相比于进程，线程的上下文切换开销更小，因为线程共享进程的地址空间和资源。
    - 共享的
      - 地址空间
      - 打开的文件
      - 全局变量
      - 信号量
  - 一个进程包含一个PCB和多个线程控制块 (Thread Control Block, TCB)
    - PCB：进程控制块，包含进程的状态信息、资源分配信息等
    - TCB：线程控制块，包含线程的状态信息、寄存器状态、栈指针等
  - 用户级线程
    - 实现: 在用户空间通过线程库实现，内核对线程无感知。线程调度由库函数完成。
  - 核心级线程
    - 线程的管理（创建、调度、同步）由操作系统内核完成。内核维护每个线程的TCB。
      - 一个线程阻塞不影响进程内其他线程的执行。
      - 内核可以直接调度线程，可以在多核CPU上实现真正的并行。
- 协程
  - 一种 用户态的、协作式 的多任务实现。
  - 可以看作是比线程更轻量级的执行单元，由 程序员/运行时 在 用户态 控制切换。
  - 协程可以在执行过程中的特定点 暂停 (yield)，然后在未来从同一点 恢复 (resume)。
  - 依赖于 编程语言或库 的支持。

## 进程线程调度的基本概念
- 为什么调度
  - 进程有多种状态，cpu根据其信息选择如何把进程塞进cpu
  - 目的的提高cpu利用率，减少等待时间，总之就是提高效率‘
  - 空闲进程
- 上下文切换发生了什么
  - 中断/系统调用触发
  - 保存当前进程上下文
    - 存程序计数器 (Program Counter, PC) 和其他CPU寄存器（通用寄存器、状态寄存器等）的值。这些值通常保存在该进程的进程控制块 (Process Control Block, PCB) 中。
    - 保存当前进程的栈指针 (Stack Pointer, SP) 和基址寄存器 (Base Register, BR) 的值。
    - 保存当前进程的内存管理信息，如页表基址寄存器 (Page Table Base Register, PTBR) 的值。
    - 更新当前进程的状态为就绪态或阻塞态，并将其从就绪队列或阻塞队列中移除。
  - 选择下一个进程
    - 根据调度算法选择下一个要运行的进程，并将其状态设置为运行态。
  - 加载新的进程上下文
    - 从新进程的 PCB 中加载程序计数器 (PC)、栈指针 (SP)、基址寄存器 (BR) 和其他寄存器的值。
    - 更新内存管理信息，如页表基址寄存器 (PTBR) 的值。
    - 恢复新进程的状态，
      - 跳转执行新进程的指令
- 上下文切换的开销
  - 上下文切换的开销主要包括保存和恢复寄存器状态、更新进程控制块 (PCB)、更新内存管理信息等操作的时间和空间开销。
  - 缓存污染 (Cache Pollution)
  - 流水线停顿 (Pipeline Stalls)  
- 调度算法的目标
  - 性能指标 
    - CPU利用率：CPU处于忙碌状态的时间占总时间的比例
    - 周转时间：从提交作业到完成作业所需的总时间
    - 等待时间：进程在就绪队列中等待CPU的时间
    - 响应时间：从提交请求到第一次响应所需的时间
    - etc
  - 根据不同的系统需求，调度算法的目标可能会有所不同。例如，在实时系统中，响应时间可能是最重要的指标，而在批处理系统中，周转时间可能更为重要。

## 调度算法实例
- 批处理系统
  - 先来先服务 (First-Come, First-Served, FCFS）
    - 按进程到达就绪队列的顺序进行调度。使用FIFO队列。
  - 最短作业优先 (Shortest Job First, SJF)
    - 贪心
    - 长任务饿死
  - 最高响应比优先
    - 非抢占式。计算每个进程的响应比 R = (等待时间 W + 服务时间 S) / 服务时间 S，选择R最高的进程。
    - 计算响应比有额外开销。
- 适用交互式系统
  - 轮转法
    - 类似于FCFS，但增加了时间片和抢占。每个进程被分配一个固定的时间片（Quantum），运行时间超出时间片后会被强制切换（抢占），放回就绪队列尾部。
    - 没有优先级，时间片过小会导致频繁的上下文切换，时间片过大则可能导致响应时间变长。
  - 优先级
    - 导致低优先级进程饿死
  - 多级队列调度
    - 将就绪队列划分为多个独立的队列，每个队列有自己的优先级和调度算法（如：前台交互队列用RR，后台批处理队列用FCFS
    - 进程无法在队列间移动。低优先级队列可能饿死。
  - 多级反馈队列调度 
    - 前者的改进
      - 可以在队列间移动
    - 一系列规则
- 实时系统
  - 目标是满足时间约束（截止时间）
  - 速率单调调度
    - 周期性任务的优先级与其执行频率（速率）成正比。周期越短（频率越高），优先级越高。
  - 动态优先级，抢占式。
  - 优先级的抢占式调度
- 抢占式和非抢占式需要基于其目标和系统需求来选择
  - 抢占式调度：允许高优先级进程抢占低优先级进程的CPU时间，适用于实时系统和交互式系统。
  - 非抢占式调度：不允许高优先级进程抢占低优先级进程的CPU时间，适用于批处理系统和长作业。

- 机制与策略分离 (Separation of Mechanism and Policy) 
  - 机制是那些在确定规则的时候规定了会干的事情，那些上下文切换、事件处理程序等等
  - 策略是那些决定了，在机制下选择会干什么的事情，比如调度算法、内存分配算法等等
  - 分离的好处是模块化，灵活，可定制
- 实例操作系统的调度算法

## 处理器调度的基本概念
- 调度的三个层次
  - 长程调度（Long-term scheduling）
    - 选择哪些进程进入内存，形成就绪队列
    - 影响系统的吞吐量和响应时间
  - 中程调度（Medium-term scheduling）
    - 选择哪些进程从内存中换出，形成阻塞队列
    - 影响系统的内存利用率和响应时间
  - 短程调度（Short-term scheduling）
    - 选择哪个进程从就绪队列中调度到CPU上执行
    - 影响系统的响应时间和CPU利用率
  - 分层来优化
- 调度时机
  - 进程开始结束
  - 阻塞发生、回归
  - 中断
- 调度的过程
  - 上下文切换 不再重复
  - xv6的swtch函数
## 实例：操作系统调度算法
- TODO 再说

# 内存管理

## 概念
- 存储
  - 多层级
  - 进程的地址空间是逻辑的，不能直接在物理内存中访问
  - 地址重定位
    - 将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址的过程。
    - 程序加载到内存的位置通常在运行时才能确定，无法在编译时预知其物理地址。
    - 地址绑定时机 (Binding Time)
      - 编译时：编译器将逻辑地址转换为物理地址，程序只能在特定的内存位置运行。
      - 加载时：操作系统在加载程序时将逻辑地址转换为物理地址，程序可以在任意内存位置运行。
      - 运行时：操作系统在程序运行时将逻辑地址转换为物理地址，程序可以在任意内存位置运行。
      - 原来越灵活
    - 过程
      - 静态
        - 加载器在加载程序时将逻辑地址转换为物理地址，程序只能在特定的内存位置运行。
      - 动态
        - 由MMU实时完成地址转换，程序可以在任意内存位置运行。
  - 存储保护
    - 基地址寄存器
    - 界限寄存器
  - 存储共享
    - 共享库
  - 局部性原理

## 进程的地址空间
"""
高地址 0xFFFFFFFF  +-----------------------+
                      | 内核地址空间 (Kernel)    | --> 供操作系统使用，用户模式不可访问
          0xC0000000  +-----------------------+
                      | 用户栈 (Stack)          | --> 函数调用、局部变量 (向下增长)         |
                      | ----------------------- |
                      |                         |
                      | 内存映射区域            | --> 共享库、内存映射文件                  |
                      | (Memory Mapped Region)  |
                      |                         |
                      | ----------------------- |
                      | 堆 (Heap)               | --> 动态内存分配 (malloc, new) (向上增长) |
                      | ----------------------- |
                      | BSS 段 (Uninit. Data)   | --> 未初始化全局/静态变量                 |
                      | ----------------------- |
                      | 数据段 (Data Segment)   | --> 已初始化全局/静态变量                 |
                      | 0x08048000              | -----------------------                   |
                      | 代码段 (Text Segment)   | --> 程序指令 (只读)                       |
    低地址  0x00000000 +-----------------------+
"""
- xv6地址空间
  - 低到高：
    - 代码段
    - 数据段
    - 栈
    - 堆
  - 高地址处有 Trampoline 和 Trapframe 区域，用于用户态和内核态之间的切换，并且在两种模式下都映射。

## 物理内存管理
- 操作系统需要跟踪哪些物理内存是空闲的，哪些已被分配。
- 管理记录的数据结构
  - 位图记录
    - bit map
  - 空闲链表
    - 每个项记录一个空闲区的起始地址 (Start Address) 和 长度 (Length)
    - 显式的
    - 隐士的
    - 分离的
      - 参见melloc的实现
- 内存资源利用率: 目标是减少浪费
- 内存分配算法 
  - 意思是在空闲列表里找一个合适的空闲区，来塞进程需要的新分配的内存（逻辑）
  - 不细说了 也是melloc里面实现过的
- 内存回收
  - 检查合并

## 特定分配策略
- 伙伴系统 (Buddy System
  - 一种特殊的“分离适配”算法，用于管理大小为 2 的幂次的内存块。Linux 内核底层内存管理曾采用（现在也部分采用）。
  - 把整个空间二次幂化，从开始分配到任何中间态的碎片都是有规律的，不会像是前面那么碎片化
- SLAB/SLUB/SLOB 分配器
  -  高效管理内核中频繁分配和释放的小内存对象（如 inode、task_struct 等）。伙伴系统分配的最小块可能仍太大，导致内碎片。
  -  把上面得到的空闲块划分成更小的块，形成一个缓存池 (Cache Pool)，或者叫固定大小的小对象
  -  每种类型的对象都有一个对应的缓存池，分配和释放时直接从缓存池中获取和释放。
  -  SLAB：最早的实现，使用了对象缓存池和队列
  -  SLUB：更高效的实现，使用了对象缓存池，不用队列
  -   SLOB：使用简单的首次适配算法在小的内存块（slab）
-   

## 基本内存管理方案
- 如何把逻辑地址映射到物理地址
- 单一连续区 
  - 内存除操作系统区域外，全部由当前运行的一个用户程序独占。
- 固定分区 
  - 预先分好，再分给进程
- 可变分区
  - 用前面的那些空闲查找方法来分配
  - 容易产生外碎片，太零碎
- 页式管理 (Paging
  - 逻辑地址空间: 划分为固定大小的块，称为 页 (Page)。
  - 物理内存空间: 划分为与页大小相同的块，称为 页框 (Page Frame) 或物理页面、内存块
  - 以页为单位进行。
    - 进程需要的页可以加载到任意空闲的页框中。逻辑上相邻的页在物理上不必相邻。
    - 逻辑地址 = 页号 (Page Number) + 页内偏移 (Offset)
  - 从而避免了太碎的问题，不会有外碎片
  - 页表 (Page Table): 每个进程都有一个页表
    - 页表项 (Page Table Entry, PTE): 页表中的每一项，包含了页号和对应的物理页框号。
    - 页表项的格式：
      - 页框号 (Frame Number): 映射到的物理页框号
      - 有效位 (Valid Bit): 表示该页是否在内存中
      - 其他位：如修改位、访问位等，用于管理和保护
    - 存储: 页表本身也存储在内存中。操作系统通过页表基址寄存器 (Page Table Base Register - PTBR) (如 x86 的 CR3 寄存器) 指向当前进程的页表起始地址。
    - 空闲页框列表: 操作系统需要维护一个数据结构（如位图或链表）来跟踪哪些物理页框是空闲的。
  - 转换过程体系讲过了
  - 内碎片：
    - 页没有用完，剩下的空间浪费了
- 段式管理 Segmentation
  - 逻辑地址空间: 按照程序的逻辑结构划分为多个段 (Segment)，如代码段、数据段、栈段等。每个段有自己的名字（通常用段号代替）和长度。段的长度可以不同。
  - 物理内存空间: 本身仍是线性，但按段分配给逻辑地址空间。
  - 逻辑地址 = 段号 (Segment Number) + 段内偏移 (Offset within Segment)
  - 段表 (Segment Table): 每个进程一个段表。
    - 类似的，段表项 (Segment Table Entry, STE) 包含段号和对应的物理地址。
    - 段表项的格式：
      - 段基址 (Base Address): 映射到的物理地址
      - 段界限 (Limit): 段的长度
      - 有效位 (Valid Bit): 表示该段是否在内存中
      - 其他位：如修改位、访问位等，用于管理和保护
    - 存储: 段表本身也存储在内存中。操作系统通过段表基址寄存器 (Segment Table Base Register - STBR) 指向当前进程的段表。
  - 物理内存管理: 类似于可变分区管理，需要维护空闲区列表，使用 First Fit 等算法分配连续空间。
  - 转换方式略去
- 段页式
  - 逻辑段内再分为页
  - 段表中每个段有一个页表

## 内存 “扩充” 技术
- 覆盖
  - 思想: 程序的不同模块（覆盖段）按照它们的调用关系在同一块内存区域中相互替换。只有当前需要的模块和常驻模块保留在内存中。
  - 通过分块，不同时，来节省内存空间
- 交换技术 (Swapping)
  - 将暂时不运行的进程完整地从内存移动到外存（交换区 Swap Space），称为换出 (Swap Out / Roll Out)。当需要再次运行时，再从外存将其换回 (Swap In / Roll In) 到内存中。
  - 虚拟内存技术 
    - 本质上就是虚拟的移动进程的东西进来，直到真的需要了才换入内存

## 虚拟内存
- 本章节的目的是详细的解释上面提到的算法，其实现的细节

